/**
 * NUteniq Solution: Firestore Security Rules (Prototyping Mode)
 *
 * ## Core Philosophy
 * This ruleset establishes a role-based access control model centered around
 * 'Staff Members' and 'Admins'. The primary security goal is to ensure that
 * sensitive business data (customers, tasks, invoices) is only accessible
 * to authenticated and authorized personnel. Unauthenticated access is denied
 * by default.
 *
 * ## Data Structure
 * Data is organized into top-level collections:
 * - /customers: Stores sensitive customer profiles.
 * - /tasks: Represents work items assigned to staff.
 * - /staff_members: Profiles for employees using the system.
 * - /invoices: Stores billing information.
 * - /roles_admin: A critical collection that defines which users have admin
 *   privileges across the entire system.
 *
 * ## Key Security Decisions
 * - Admin Privilege: A user is considered an 'Admin' if a document with their
 *   UID exists in the `/roles_admin` collection. This provides a single,
 *   performant source of truth for the highest level of access.
 * - Staff Access: Staff members have limited, specific access. For example, a
 *   staff member can access a task only if they are directly assigned to it
 *   via the `assigneeId` field.
 * - Default Deny: All collections are locked down by default. Access is only
 *   granted explicitly to admins or to staff members based on their specific
 *   relationship to a document (e.g., being the assignee of a task).
 * - Client Query Responsibility: List operations on collections containing
 *   mixed-sensitivity data (like `/tasks`) are restricted to admins. This
 *   prevents clients from performing broad, unfiltered queries. Client
 *   applications are responsible for building secure, targeted queries (e.g.,
 *   `collection('tasks').where('assigneeId', '==', currentUser.uid)`) which
 *   are then enforced by the per-document `get` rules.
 * - Immutable Roles: The `/roles_admin` collection is read-only from a client
 *   perspective to prevent privilege escalation or accidental lockouts. Admin
 *   roles should be managed through the Firebase Console or a secure backend
 *   process.
 *
 * ## Denormalization for Authorization
 * The ruleset relies heavily on denormalization for fast and secure checks.
 * The `assigneeId` field is denormalized onto each `Task` document, allowing
 * rules to grant access without performing extra `get()` calls to other
 * collections. This is crucial for performance and scalability.
 *
 * ## Structural Segregation
 * Each top-level collection (`customers`, `tasks`, etc.) represents a distinct
 * data type with a unified security model, simplifying the rules and making
 * them easier to audit and maintain.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has admin privileges.
     * Admin status is granted if a document with the user's UID exists in the
     * /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is used to verify document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is the assigned staff member for a resource.
     */
    function isAssignee(assigneeId) {
      return isSignedIn() && request.auth.uid == assigneeId;
    }

    /**
     * Ensures an incoming document has a consistent ID field on creation.
     */
    function hasConsistentIdOnCreate(docId) {
      return request.resource.data.id == docId;
    }

    /**
     * Ensures the ID field of a document is immutable on update.
     */
    function idIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages sensitive customer profiles. Only admins can read or write this data.
     * @path /customers/{customerId}
     * @allow An admin (create) a new customer document. `auth.uid` exists in `/roles_admin`.
     * @deny A non-admin staff member (get) a customer document.
     * @principle Enforces strict role-based access control (Admin-only) for sensitive data.
     */
    match /customers/{customerId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && hasConsistentIdOnCreate(customerId);
      allow update: if isAdmin() && resource != null && idIsImmutable();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages tasks assigned to staff. Access is granted to the assignee or any admin.
     * @path /tasks/{taskId}
     * @allow A staff member (get) a task where `resource.data.assigneeId` matches their UID.
     * @deny A staff member (list) all tasks in the collection. Listing is admin-only to prevent data leakage.
     * @principle Enforces access based on denormalized relationship data (`assigneeId`) and role (Admin).
     */
    match /tasks/{taskId} {
      allow get: if isAdmin() || (isSignedIn() && isAssignee(resource.data.assigneeId));
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if resource != null && (isAdmin() || isAssignee(resource.data.assigneeId));
      allow delete: if resource != null && (isAdmin() || isAssignee(resource.data.assigneeId));
    }

    /**
     * @description Manages staff member profiles. Admins have full control, while a staff member can read their own profile.
     * @path /staff_members/{staffMemberId}
     * @allow A staff member (get) their own profile document, where `staffMemberId` matches their UID.
     * @deny A staff member (update) another staff member's profile.
     * @principle Combines role-based access (Admin) for management with document ownership for self-service reads.
     */
    match /staff_members/{staffMemberId} {
      allow get: if isAdmin() || isOwner(staffMemberId);
      allow list: if isAdmin();
      allow create: if isAdmin() && hasConsistentIdOnCreate(staffMemberId);
      allow update: if isAdmin() && resource != null && idIsImmutable();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages invoice data. Only admins can read or write this data.
     * @path /invoices/{invoiceId}
     * @allow An admin (delete) an invoice document. `auth.uid` exists in `/roles_admin`.
     * @deny A non-admin user (get) an invoice document.
     * @principle Enforces strict role-based access control (Admin-only) for financial data.
     */
    match /invoices/{invoiceId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && hasConsistentIdOnCreate(invoiceId);
      allow update: if isAdmin() && resource != null && idIsImmutable();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines user roles. This collection is the source of truth for admin privileges.
     * It is read-only for admins and completely locked for writes to prevent client-side privilege changes.
     * @path /roles_admin/{userId}
     * @allow An admin (get) the role document of another user to check if they are an admin.
     * @deny Any user, including an admin, (create) or (delete) a role document. This must be done server-side.
     * @principle Secures the role-granting mechanism by making it immutable from client applications.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}